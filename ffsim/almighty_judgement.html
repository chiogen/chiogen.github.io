<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Almighty Judgement Mechanic</title>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="fightCanvas"></canvas>
  <script>
    const canvas = document.getElementById('fightCanvas');
    const ctx = canvas.getContext('2d');
    let arena = { x: 0, y: 0, radius: 0 };
    let positions = [];

    const patterns = [
      [2, 5, 10, 14, 15, 17, 21, 23],
      [0, 4, 8, 11, 12, 13, 16, 20, 24],
      [1, 3, 7, 9, 10, 18, 19, 22]
    ];

    const player = { x:0, y:0, radius:15, speed:160 };
    const keys = {};

    const circleRadius = 200;
    const markerRadius = 20;
    const markerSquareSize = 40;
    const previewInterval = 2000;
    const activeInterval = 2000;
    const castDuration = 3000;
    const endDuration = 3000;
    const betweenPreviewActiveDelay = 2000; // delay in ms between preview end and activation start

    let sequence = shuffleArray([0,1,2]);
    let state = 'casting';
    let activePattern = [];
    let justActivated = false;
    let castStart;
    let endStart;

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
    window.addEventListener('keyup',   e=>keys[e.key.toLowerCase()]=false);

    castStart = performance.now();
    requestAnimationFrame(gameLoop);

    function resizeCanvas(){
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      arena.x = canvas.width/2;
      arena.y = canvas.height/2;
      arena.radius = Math.min(canvas.width,canvas.height)/2 - 20;
      positions = [];
      const step = (arena.radius*2)/4;
      for(let y=0;y<5;y++){
        for(let x=0;x<5;x++){
          const xOff = -arena.radius + step*x;
          const yOff = -arena.radius + step*y;
          positions.push({ x:arena.x+xOff, y:arena.y+yOff });
        }
      }
      player.x = arena.x;
      player.y = arena.y;
    }

    function startPreview() {
      state = 'preview';
      // schedule each preview in order
      sequence.forEach((idx, i) => {
        setTimeout(() => {
          activePattern = patterns[idx];
        }, i * previewInterval);
      });
      // after previews end, enter waiting state
      setTimeout(() => {
        state = 'waiting';
        activePattern = [];
      }, sequence.length * previewInterval);
      // schedule start of active phase after previews + extra delay
      setTimeout(startActive, sequence.length * previewInterval + betweenPreviewActiveDelay);
    }


    function startActive() {
      state = 'active';
      sequence.forEach((idx, i) => {
        setTimeout(() => {
          activePattern = patterns[idx];
          justActivated = true;
          if (i === sequence.length - 1) {
            setTimeout(() => {
              state = 'success'; endStart = performance.now();
            }, activeInterval);
          }
        }, i * activeInterval);
      });
    }

    function gameLoop(ts){
      update(1/60, ts);
      draw(ts);
      requestAnimationFrame(gameLoop);
    }

    function update(dt, ts){
      if(state==='casting'){
        if(ts - castStart >= castDuration) startPreview();
        return;
      }
      if(state==='failed' || state==='success'){
        if(ts - endStart >= endDuration) location.reload();
        return;
      }
      let dx=0, dy=0;
      if(keys['w']) dy--;
      if(keys['s']) dy++;
      if(keys['a']) dx--;
      if(keys['d']) dx++;
      const len = Math.hypot(dx,dy);
      if(len>0){ dx/=len; dy/=len;
        player.x+=dx*player.speed*dt;
        player.y+=dy*player.speed*dt;
        const d = Math.hypot(player.x-arena.x, player.y-arena.y);
        if(d>arena.radius-player.radius){
          const ang=Math.atan2(player.y-arena.y, player.x-arena.x);
          player.x=arena.x+(arena.radius-player.radius)*Math.cos(ang);
          player.y=arena.y+(arena.radius-player.radius)*Math.sin(ang);
        }
      }
      if(state==='active' && justActivated){
        activePattern.forEach(i=>{
          const p=positions[i];
          if(Math.hypot(player.x-p.x,player.y-p.y)<circleRadius) fail();
        });
        justActivated=false;
      }
    }

    function draw(ts){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawArena();
      drawMarkers();
      if(state==='casting') return drawCastBar(ts);
      drawPattern();
      drawPlayer();
      if(state==='failed') drawEndText('Failed');
      if(state==='success') drawEndText('Success');
    }

    function drawArena(){
      ctx.strokeStyle='#fff'; ctx.lineWidth=4;
      ctx.beginPath();
      ctx.arc(arena.x,arena.y,arena.radius,0,2*Math.PI);
      ctx.stroke();
    }

    // Markers A-D,1-4
    const markers = [
      {idx:2,label:'A',color:'red'},
      {idx:9,label:'B',color:'yellow'},
      {idx:22,label:'C',color:'blue'},
      {idx:10,label:'D',color:'purple'},
      {idx:13,label:'1',color:'red'},
      {idx:14,label:'2',color:'yellow'},
      {idx:17,label:'3',color:'blue'},
      {idx:18,label:'4',color:'purple'}
    ];
    function drawMarkers(){
      markers.forEach(m=>{
        const p = positions[m.idx];
        // shape around marker
        ctx.strokeStyle = m.color;
        ctx.lineWidth = 3;
        if(/[A-D]/.test(m.label)) {
          // circle around
          ctx.beginPath();
          ctx.arc(p.x, p.y, markerRadius, 0, 2*Math.PI);
          ctx.stroke();
        } else {
          // square around
          const size = circleRadius;
          ctx.beginPath();
          ctx.rect(p.x - markerSquareSize/2, p.y - markerSquareSize/2, markerSquareSize, markerSquareSize);
          ctx.stroke();
        }
        // draw label
        ctx.fillStyle = m.color;
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(m.label, p.x, p.y);
      });
    }

    function drawPattern(){
      ctx.fillStyle = state==='preview'? 'rgba(0,0,255,0.3)' : 'rgba(255,0,0,0.5)';
      activePattern.forEach(i=>{
        const p = positions[i];
        ctx.beginPath(); ctx.arc(p.x,p.y,circleRadius,0,2*Math.PI); ctx.fill();
      });
    }

    function drawPlayer(){
      ctx.fillStyle='#0f0';
      ctx.beginPath(); ctx.arc(player.x,player.y,player.radius,0,2*Math.PI); ctx.fill();
    }

    function drawCastBar(ts){
      const elapsed = ts - castStart;
      const frac = Math.min(elapsed/castDuration,1);
      const w = arena.radius*2;
      const h = 20;
      ctx.fillStyle='#222'; ctx.fillRect(arena.x-arena.radius, arena.y+h, w, h);
      ctx.fillStyle='#ebe833'; ctx.fillRect(arena.x-arena.radius, arena.y+h, w*frac, h);
      ctx.fillStyle='#fff'; ctx.font='18px sans-serif'; ctx.textAlign='center';
      ctx.fillText('Almighty Judgement', arena.x, arena.y+h*2+10);
    }

    function drawEndText(text){
      ctx.fillStyle='#fff'; ctx.font='48px sans-serif';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(text, arena.x, arena.y);
    }

    function fail(){ state='failed'; endStart = performance.now(); }

    function shuffleArray(arr){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  </script>
</body>
</html>
